# Visualization `r emo::ji('chart_decreasing')`


<!-- NOTE 09/27: REVAMP THIS SECTION, ANSWER QUESTIONS ABOUT THE DATA MORE -->


<!-- NOTE 05/24: I'm thinking should calculate % change just for visualization purposes just here, but what if we avoid that completely and instead make the tutorial on visualizing price over time for BTC first and then creating gganimate tutorial to iterate over the rest? Just keep it to ggplot2 + extensions + gganimate tutorial here, no need to make a million visualizations. Would be good to add rayshader too, but add that as a stretch goal for later. -->

Making visualizations using `ggplot2` is one of the very best tools available in the R ecosystem. The ***gg*** in `ggplot2` stands for the ***Grammar of Graphics***, which is essentially the idea that many different types of charts share the same underlying building blocks, and that they can be put together in different ways to make charts that look very different from each other. [In Hadley's own words,](https://qz.com/1007328/all-hail-ggplot2-the-code-powering-all-those-excellent-charts-is-10-years-old/) "a pie chart is just a bar chart drawn in polar coordinates", "They look very different, but in terms of the grammar they have a lot of underlying similarities."


## Basics - ggplot2

So how does `ggplot2` actually work? ***"...in most cases you start with `ggplot()`, supply a dataset and aesthetic mapping (with `aes()`). You then add on layers (like `geom_point()` or `geom_histogram()`), scales (like `scale_colour_brewer()`), faceting specifications (like `facet_wrap()`) and coordinate systems (like `coord_flip()`)."*** - [ggplot2.tidyverse.org/](https://ggplot2.tidyverse.org/).

Let's break this down step by step.

***"start with ggplot(), supply a dataset and aesthetic mapping (with aes())***


```{r ggplot_blank}
ggplot(data = cryptodata, aes(x = date_time_utc, y = price_usd))
```


The chart now shows up but is blank because we need to perform an additional step ***"You then add on layers (like `geom_point()` or `geom_histogram()`)..."***

We can take the exact same code as above and add ***+ `geom_point()`***

```{r ggplot_geom_point}
ggplot(data = cryptodata, aes(x = date_time_utc, y = price_usd)) +
       # adding geom_point():
       geom_point()
```

The most expensive cryptocurrency being shown, `r subset(cryptodata, price_usd == max(cryptodata$price_usd))$symbol` in this case, makes it difficult to take a look at any of the other ones. Let's try *zooming-in* on a single one by using the same code but making an adjustment to the `data` parameter to only show data for the cryptocurrency with the symbol *ETH*, first let's filter the data down to those results only:
```{r ETH_subset}
eth_data <- subset(cryptodata, symbol == 'ETH')
```

```{r ggplot_ETH}
ggplot(data = eth_data, 
       aes(x = date_time_utc, y = price_usd)) + 
       geom_point()
```

*The axis automatically adjusted to the new data.*

This is better, but geom_point() might not be the best choice for this chart, let's change `geom_point` with `geom_line` and see what that looks like:

```{r ggplot_ETH_line}
ggplot(data = eth_data, 
       aes(x = date_time_utc, y = price_usd)) + 
       # changing geom_point() into geom_line():
       geom_line()
```

Let's save the results as an object called `crypto_chart`:
```{r}
crypto_chart <- ggplot(data = eth_data, 
                       aes(x = date_time_utc, y = price_usd)) + 
                       geom_line()
```

We can add a line showing the trend over time:

```{r ggplot_ETH_lm_relationship}
crypto_chart <- crypto_chart + stat_smooth()
crypto_chart
```

One particularly nice aspect of using the ggplot framework, is that we can keep adding as many elements and transformations to the chart as we would like with no limitations. 

We will not save the next result, but to illustrate this point, we can add a new line showing a linear regression fit going through the data using `stat_smooth(method = 'lm')`. And let's also show the individual points in green to show we can keep layering things as much as we want.

```{r}
crypto_chart + 
        # Add linear regression line
        stat_smooth(method = 'lm', color='red') + 
        # Add points
        geom_point(color='dark green', size=0.8)
```

By not providing any `method` option, the `stat_smooth()` function defaults to use the `method` called [`loess`, which shows the local trends](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess), while the `lm` model fits the best fitting linear regression line for the data as a whole.

Of course we can add other components that make a visualization effective, let's add labels to the chart now:
```{r ggplot_labels}
crypto_chart <- crypto_chart +
                  ggtitle(paste('Price Change Over Time -', eth_data$symbol),
                          subtitle = paste('Most recent data collected on:', max(eth_data$date_time_utc))) + 
                  xlab('Date Time (UTC)') +
                  ylab('Price ($)')
# display the new chart
crypto_chart
```

The `ggplot2` package comes with a large amount of functionality. You can find a full reference of the functions you can use here:

```{r show_ggplot2_ref, echo=F}
knitr::include_url("https://ggplot2.tidyverse.org/reference/")
```
*https://ggplot2.tidyverse.org/reference/*


What makes the `ggplot2` package **even better** is the fact that [it also comes with a framework for anyone to develop their own extensions](https://cran.r-project.org/web/packages/ggplot2/vignettes/extending-ggplot2.html). Meaning there is a lot more functionality that the community has created that can be added in importing other packages that provide extensions to ggplot.

## Using Extensions

### ggthemes

To use an extension, we just need to import it into our R session like we did with `ggplot2` and the rest of the packages we want to use. We [already loaded the `ggthemes` [@R-ggthemes] package in the Setup section](#setup) so we do not need to run `library(ggthemes)` to import the package into the session.

We can apply a *theme* to the chart now and change the way it looks:

```{r ggthemes, message=FALSE, warning=FALSE}
crypto_chart <- crypto_chart + theme_economist()
# display the new chart
crypto_chart
```

See below for a full list of themes you can test. If you followed to this point try running the code `crypto_chart + theme_excel()` or any of the other options listed below instead of `+ theme_excel()`:
```{r show_ggthemes_site, echo=F}
knitr::include_url("https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/", heigth='500px')
```
*https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/*


### plotly
In some cases, it's helpful to make a chart responsive to a cursor hovering over it. We can convert any ggplot into an interactive chart by using the `plotly` [@R-plotly] package, and it is super easy!

We already imported the `plotly` package [in the setup section](#setup), so all we need to do is wrap our chart in the function `ggplotly()`:

<!-- CAUSES ISSUES 06/11 -->
```{r plotly, message=FALSE, warning=FALSE}
ggplotly(crypto_chart) # notice that we did not overwrite the crypto_chart object this time
```

If you are not looking to convert a ggplot, plotly also provides its own framework for making charts from scratch, you can find out more about it here:
```{r show_plotly_website, echo=F}
knitr::include_url("https://plotly.com/r/")
```
***https://plotly.com/r/***

<!-- NOT WORKING ANYMORE ON 10/21/2020: -->
### ggpubr

The `ggpubr` [@R-ggpubr] extension provides a lot of functionality that we won't cover here, but one function we can use from this extension is `stat_cor()`, which allows us to add a correlation coefficient (R) and p-value to the chart.

```{r ggpubr, message=FALSE, warning=FALSE, error=TRUE}
crypto_chart <- crypto_chart + stat_cor()
# Show chart
crypto_chart
```

We will dive deeper into these metrics in [the section where we evaluate the performance of the models](#evaluate-model-performance).

### ggforce

The `ggforce` package [@R-ggforce] is a useful tool for annotating charts. We can annotate outliers for example:

```{r add_ggforce_annotations, error=TRUE}
crypto_chart <- crypto_chart +
                  geom_mark_ellipse(aes(filter = price_usd == max(price_usd),
                          label = date_time_utc,
                          description = paste0('Price spike to $', price_usd))) +
                  geom_mark_ellipse(aes(filter = price_usd == min(price_usd),
                          label = date_time_utc,
                          description = paste0('Price drop to $', price_usd)))
```

When using the `geom_mark_ellipse()` function we are passing the `data` argument, the `label` and the `description` through the `aes()` function. We are marking two points, one for the minimum price during the time period, and one for the maximum price. For the first point we filter the data to only the point where the `price_usd` was equal to the `max(price_usd)` and add the labels accordingly. The same is done for the second point, but showing the lowest price point for the given date range.

Now view the new chart:
```{r}
crypto_chart
```

Notice that this chart is specifically annotated around these points, but we never specified the specific dates to circle, and we are always circling the maximum and minimum values regardless of the specific data. One of the points of this document is to show the idea that when it comes to data analysis, visualizations, and reporting, most people in the workplace approach these as one time tasks, but with the proper (open source/free) tools automation and reproducibility becomes a given, and any old analysis can be run again to get the exact same results, or could be performed on the most recent view of the data using the same exact methodology.


### gganimate

We can also extend the functionality of ggplot by using the `gganimate` [@R-gganimate] package, which allows us to create an animated GIF that iterates over groups in the data through the use of the `transition_states()` function.
```{r first_gganimate, message=FALSE, warning=FALSE, error=TRUE}
animated_prices <- ggplot(data = mutate(cryptodata, groups=symbol),
                          aes(x = date_time_utc, y = price_usd)) +
                          geom_point() +
                          transition_states(groups) +
                          stat_smooth() +
                          ggtitle('Price Over Time',subtitle = '{closest_state}') +
                          view_follow() # this adjusts the axis based on the group
# Show animation (slowed to 1 frame per second):
animate(animated_prices,fps=1)
```

We recommend consulting this documentation for simple and straightforward examples on using gganimate: https://gganimate.com/articles/gganimate.html


### ggTimeSeries

The `ggTimeSeries` [@R-ggTimeSeries] package has functionality that is helpful in plotting time series data. We can create a calendar heatmap of the price over time using the `ggplot_calendar_heatmap()` function.

```{r ggtimeseries_heatmap, error=TRUE}
calendar_heatmap <- ggplot_calendar_heatmap(eth_data,'date_time_utc','price_usd') #or do target_percent_change here?
calendar_heatmap
```

*DoW on the y-axis stands for Day Of the Week*

To read this chart in the correct date order start from the top left and work your way down and to the right once you reach the bottom of the column. The lighter the color the higher the price on the specific day.

### Rayshader

The previous chart is helpful, but a color scale like that can be a bit difficult to interpret. We could convert the previous chart into a 3d figure that is easier to visually interpret by using the amazing `rayshader` [@R-rayshader] package. 
<!-- [TODO - NEED TO MANUALLY FIX THIS CITATION! Add new .bib file, right now just packages.bib which is automatically overwritten each time.] -->

**This document runs automatically through GitHub Actions, which [does not have a graphical environment to run the code below](https://github.community/t/installation-of-xquartz-not-found/139804), which prevents it from refreshing the results with the latest data. We are showing old results for the Rayshader section below. If you have gotten to this point, run the code below yourself on the latest data to see this amazing package in action!**

```{r rayshader_cal_heatmap, eval=FALSE}
# First remove the title from the legend to avoid visual issues
calendar_heatmap <- calendar_heatmap + theme(legend.title = element_blank())
# Add the date to the title to make it clear these refresh twice daily
calendar_heatmap <- calendar_heatmap + ggtitle(paste0('Through: ',substr(max(eth_data$date_time_utc),1,10)))
# Convert to 3d plot
plot_gg(calendar_heatmap, zoom = 0.60, phi = 35, theta = 45)
# Render snapshot
render_snapshot('rayshader_image.png')
# Close RGL (which opens on plot_gg() command in a separate window)
rgl.close()
```

![](rayshader_image.png)

This is the same two dimensional [calendar heatmap that was made earlier](#calendar-heatmap).

Because we can programmatically adjust the camera as shown above, that means that we can also create a snapshot, move the camera and take another one, and keep going until we have enough to make it look like a video! This is not difficult to do using the `render_movie()` function, which will take care of everything behind the scenes for the same plot as before:
```{r rayshader_render_movie, eval=FALSE}
# This time let's remove the scale too since we aren't changing it:
calendar_heatmap <- calendar_heatmap + theme(legend.position = "none")
# Same 3d plot as before
plot_gg(calendar_heatmap, zoom = 0.60, phi = 35, theta = 45)
# Render movie
render_movie('rayshader_video.mp4')
# Close RGL
rgl.close()
```

*Click on the video below to play the output*

![](rayshader_video.mp4)

Awesome! Move on to the [next section](#predictive-modeling) to start making predictive models for the data..

